import{_ as e,c as t,o as l,d}from"./app.4b9a283d.js";const x=JSON.parse('{"title":"《现代Web布局》其一：布局及 flex 基础","description":"","frontmatter":{"title":"《现代Web布局》其一：布局及 flex 基础","icon":"css","isOriginal":true,"date":"2022-12-05T00:00:00.000Z","category":["读书笔记","前端"],"tag":["css","前端"],"image":"","banner":""},"headers":[{"level":2,"title":"参考内容","slug":"参考内容","link":"#参考内容","children":[]},{"level":2,"title":"Web 布局演进史","slug":"web-布局演进史","link":"#web-布局演进史","children":[]},{"level":2,"title":"Web 布局技术术语","slug":"web-布局技术术语","link":"#web-布局技术术语","children":[{"level":3,"title":"逻辑坐标系","slug":"逻辑坐标系","link":"#逻辑坐标系","children":[]},{"level":3,"title":"容器和容器空间","slug":"容器和容器空间","link":"#容器和容器空间","children":[]}]},{"level":2,"title":"Flex 基础","slug":"flex-基础","link":"#flex-基础","children":[{"level":3,"title":"重要概念","slug":"重要概念","link":"#重要概念","children":[]}]},{"level":2,"title":"flex 容器中的对齐方式","slug":"flex-容器中的对齐方式","link":"#flex-容器中的对齐方式","children":[{"level":3,"title":"属性分类","slug":"属性分类","link":"#属性分类","children":[]},{"level":3,"title":"理解“空间分配”","slug":"理解-空间分配","link":"#理解-空间分配","children":[]},{"level":3,"title":"理解“对齐属性”","slug":"理解-对齐属性","link":"#理解-对齐属性","children":[]},{"level":3,"title":"那么主轴上要怎么对齐呢？","slug":"那么主轴上要怎么对齐呢","link":"#那么主轴上要怎么对齐呢","children":[]},{"level":3,"title":"对齐防溢出","slug":"对齐防溢出","link":"#对齐防溢出","children":[]}]}],"relativePath":"posts/tech/《现代Web布局》其一：布局及 flex 基础.md","lastUpdated":1678177559000}'),o={name:"posts/tech/《现代Web布局》其一：布局及 flex 基础.md"},a=d('<p>第 1~4 节，介绍了</p><ol><li>Web 布局发展史</li><li>布局术语</li><li>Flex 基础</li><li>Flex 对齐基础</li></ol><h2 id="参考内容" tabindex="-1">参考内容 <a class="header-anchor" href="#参考内容" aria-hidden="true">#</a></h2><p><a href="https://juejin.cn/book/7161370789680250917" target="_blank" rel="noreferrer">稀土掘金——现代 Web 布局</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox" target="_blank" rel="noreferrer">MDN——flex 布局的基本概念</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Aligning_Items_in_a_Flex_Container" target="_blank" rel="noreferrer">MDN——Flex 容器中的对齐方式</a></p><h2 id="web-布局演进史" tabindex="-1">Web 布局演进史 <a class="header-anchor" href="#web-布局演进史" aria-hidden="true">#</a></h2><p>无任何布局 -&gt; 表格布局 -&gt; 浮动、定位布局 -&gt; 框架布局 -&gt; 现代布局 -&gt; 未来布局</p><h2 id="web-布局技术术语" tabindex="-1">Web 布局技术术语 <a class="header-anchor" href="#web-布局技术术语" aria-hidden="true">#</a></h2><h3 id="逻辑坐标系" tabindex="-1">逻辑坐标系 <a class="header-anchor" href="#逻辑坐标系" aria-hidden="true">#</a></h3><p><code>inline</code> 轴（内联轴），文本阅读方向。</p><p><code>block</code> 轴（块轴），文本换行方向。</p><table><thead><tr><th>物理属性</th><th>逻辑属性(<code>horizontal-tb</code>)</th><th>逻辑属性(<code>vertical-lr</code>)</th></tr></thead><tbody><tr><td>x轴(水平轴)</td><td>inline轴(内联轴)</td><td>block轴(块轴)</td></tr><tr><td>y轴(垂直轴)</td><td>block轴(块轴)</td><td>inline轴(内联轴)</td></tr></tbody></table><blockquote><p><strong>注意</strong>，不管是物理坐标系还是逻辑坐标系中，<code>z</code> 轴是不变的！</p></blockquote><h3 id="容器和容器空间" tabindex="-1">容器和容器空间 <a class="header-anchor" href="#容器和容器空间" aria-hidden="true">#</a></h3><p><img src="https://s2.loli.net/2022/12/08/64emx2HrKVFu7vf.jpg" alt="新盒子模型"></p><p>把原先的 <code>left</code>、<code>right</code> 等方位词，替换成 <code>start</code>、<code>end</code> 等逻辑词，便于构建不同语言的应用。</p><p>按容器内放置内容的多少，有 <strong>可用空间</strong> 和 <strong>不可用空间</strong>。</p><h2 id="flex-基础" tabindex="-1">Flex 基础 <a class="header-anchor" href="#flex-基础" aria-hidden="true">#</a></h2><h3 id="重要概念" tabindex="-1">重要概念 <a class="header-anchor" href="#重要概念" aria-hidden="true">#</a></h3><ol><li><p>flexbox 是一种 <strong>一维布局</strong></p></li><li><p>flexbox 的两根轴线</p><p><strong>主轴</strong> 和 <strong>交叉轴(垂直轴)</strong>，可以使用 <code>flex-direction</code> 交换。</p></li><li><p>起始线和终止线</p></li><li><p>flex 容器和子元素</p><p><code>display: flex</code> 的区域被叫做 <strong>flex 容器</strong>(flex-container)，其直系子元素会变成 <strong>flex 子元素</strong>(flex item)</p></li></ol><h4 id="flex-容器的一些默认行为" tabindex="-1">flex 容器的一些默认行为 <a class="header-anchor" href="#flex-容器的一些默认行为" aria-hidden="true">#</a></h4><ul><li><p>元素排成一行（<code>flex-direction</code> 属性初始值是 <code>row</code>）</p></li><li><p>元素从主轴起始线开始</p></li><li><p><strong>元素不会在主维度度方向拉伸，但是可以缩小</strong></p></li><li><p><strong>元素被拉伸来填充交叉轴大小</strong></p></li><li><p><code>flex-basis</code> 属性为 <code>auto</code></p></li><li><p><code>flex-wrap</code> 属性为 <code>nowrap</code></p></li></ul><h4 id="多行-flex-容器" tabindex="-1">多行 flex 容器 <a class="header-anchor" href="#多行-flex-容器" aria-hidden="true">#</a></h4><blockquote><p>虽然 flexbox 是一维模型，但可以使我们的flex项目应用到多行中。</p><p>在这样做的时候，<strong>您应该把每一行看作一个新的flex容器。任何空间分布都将在该行上发生，而不影响该空间分布的其他行。</strong></p></blockquote><h2 id="flex-容器中的对齐方式" tabindex="-1">flex 容器中的对齐方式 <a class="header-anchor" href="#flex-容器中的对齐方式" aria-hidden="true">#</a></h2><p><a href="https://www.w3.org/TR/css-align-3/" target="_blank" rel="noreferrer">CSS Box Alignment 模块</a>，这玩意儿通用于 <code>flex</code> 和 <code>grid</code> 布局中，所以会发现两边的对齐语法一致。</p><p><img src="https://s2.loli.net/2022/12/08/8G1ERpS9jfl3QiB.jpg" alt="对齐模式总结图"></p><h3 id="属性分类" tabindex="-1">属性分类 <a class="header-anchor" href="#属性分类" aria-hidden="true">#</a></h3><p>属性分为两组：</p><h4 id="空间分配属性" tabindex="-1">空间分配属性 <a class="header-anchor" href="#空间分配属性" aria-hidden="true">#</a></h4><ul><li><code>justify-content</code></li><li><code>align-content</code></li><li><code>place-content</code></li></ul><h4 id="对齐属性" tabindex="-1">对齐属性 <a class="header-anchor" href="#对齐属性" aria-hidden="true">#</a></h4><ul><li><code>align-self</code></li><li><code>align-items</code></li><li><code>justify-self</code> （flex布局中没有）</li><li><code>justify-items</code> （flex布局中没有）</li></ul><h3 id="理解-空间分配" tabindex="-1">理解“空间分配” <a class="header-anchor" href="#理解-空间分配" aria-hidden="true">#</a></h3><p>主轴 &amp; 垂直轴上，flex 容器尺寸减去 flex 子元素尺寸，剩下的就是 <strong>剩余空间</strong>（可能是负值，即内容溢出）。</p><p>空间分配即对容器剩余空间的分配。</p><h4 id="沿主轴分配剩余空间-——-justify-content" tabindex="-1">沿主轴分配剩余空间 —— justify-content <a class="header-anchor" href="#沿主轴分配剩余空间-——-justify-content" aria-hidden="true">#</a></h4><table><thead><tr><th><code>justify-content</code> 值</th><th>对齐效果（默认ltr）</th><th>剩余空间分布</th></tr></thead><tbody><tr><td><code>start</code> or <code>flex-start</code></td><td>左对齐</td><td>集中在右侧</td></tr><tr><td><code>end</code> or <code>flex-end</code></td><td>右对齐</td><td>集中在左侧</td></tr><tr><td><code>center</code></td><td>居中对齐</td><td>平分在两端</td></tr><tr><td><code>space-between</code></td><td>两边贴住边缘，子元素间间距相等</td><td>均匀地分布在子元素间（同一行）</td></tr><tr><td><code>space-evenly</code></td><td>两边边缘、子元素间间距均相等</td><td>均匀地分布在子元素间 &amp; 子元素两端边缘（同一行）</td></tr><tr><td><code>space-around</code></td><td>类似每个子元素设置了 <code>margin: n 0</code></td><td>子元素间间距 n，子元素两端间距 0.5n（同一行）</td></tr></tbody></table><h4 id="沿垂直轴分配剩余空间-——-align-content" tabindex="-1">沿垂直轴分配剩余空间 —— align-content <a class="header-anchor" href="#沿垂直轴分配剩余空间-——-align-content" aria-hidden="true">#</a></h4><blockquote><p>沿垂直轴分配空间，又可以看作是 FlexBox 布局中多行（或多列） 的对齐方式</p></blockquote><p>首先，<code>align-content</code> 的默认值是 <code>stretch</code>，它会 <strong>改变子元素的垂直轴大小！</strong>（如果你未手动指定子元素的 <code>block-size</code>）</p><p><strong>拉伸在垂直轴上拉伸每一行，占满垂直轴</strong>（如果是多行，每行宽度均等），导致垂直轴没有剩余空间。</p><p>即使你手动为每个子元素设定了垂直轴方向的大小，行所占大小依然不会改变，如下图：</p><p><img src="https://s2.loli.net/2022/12/08/7FCpmnEA9ZxgMGd.jpg" alt="垂直轴“弹性行”示意"></p><p>此时，图中虚线部分就产生了剩余空间。</p><p>这时，再使用 <code>align-content</code> 就能产生效果了，具体表现类似上面的表格，不再赘述。</p><blockquote><p>再次提醒，<code>align-content</code> 属性只有在 <code>flex-wrap</code> 取值为 <code>wrap</code> 或 <code>wrap-reverse</code> 时才有效！</p></blockquote><h3 id="理解-对齐属性" tabindex="-1">理解“对齐属性” <a class="header-anchor" href="#理解-对齐属性" aria-hidden="true">#</a></h3><p><code>flex</code> 中的对齐属性，只在垂直轴有效。</p><blockquote><p>沿垂直轴对齐 Flex 子元素，单行（或单例）以及单个 Flex 子元素的对齐方式</p></blockquote><p><strong>Flex 容器中的每一行都有自己的主轴和垂直轴方向。</strong></p><p>对齐时，他们的参照不是整个容器，而是当前所在的行。</p><p><img src="https://s2.loli.net/2022/12/08/umWS5dYvcPpFB9g.jpg" alt="align-content 和 align-items 的区别图示"></p><p>另外还值得一提的是 <code>align-seft</code>：</p><blockquote><p>当 <code>align-self</code> 碰上了 <code>align-content</code> 属性时，只有 <code>align-content</code> 属性值为 <code>stretch</code> 时，<code>align-self</code> 属性的值才有效。</p></blockquote><h3 id="那么主轴上要怎么对齐呢" tabindex="-1">那么主轴上要怎么对齐呢？ <a class="header-anchor" href="#那么主轴上要怎么对齐呢" aria-hidden="true">#</a></h3><p>你已经很熟悉了，使用 <code>margin: auto</code>。</p><h3 id="对齐防溢出" tabindex="-1">对齐防溢出 <a class="header-anchor" href="#对齐防溢出" aria-hidden="true">#</a></h3><p><img src="https://s2.loli.net/2022/12/08/z4cmeYl3NULq9Ks.webp" alt="防溢出图示"></p><p><code>safe</code> 属性可以防止数据丢失，但是目前只有火狐支持该特性。</p><p>不过可以使用 <code>margin:auto</code> 来达到类似的效果。</p>',62),r=[a];function i(c,n,h,s,p,f){return l(),t("div",null,r)}const b=e(o,[["render",i]]);export{x as __pageData,b as default};
